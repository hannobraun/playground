# This is attempt number 2 to imagine building a triangle, but this time from a
# more traditional concatenative language (insofar concatenative languages are
# traditional); a simple stack-based one.

# I figure that this language has no special syntax for defining functions. It's
# just something along the lines of `:name [a b c] define`, where `:name` is the
# parameter that defines the function name, `[a b c]` is the list of words that
# constitute the function body, and `define` is a function call that takes these
# and defines the function. After the `define` call, the function can be called
# by writing `name`, which would be identical to writing `a b c`.
#
# Here, we imagine `param` as a wrapper around `define`. It calls into the
# runtime to define a parameter of the given name and type, as well as defines a
# function that accesses and returns the signal for that parameter.
#
# `param` could also be a built-in function, of course, but it seems more
# elegant to provide a lower-level and more flexible API of built-in functions,
# then have the higher-level API defined in the language itself.
#
# However we do it, after this, 3 functions (`a`, `b`, and `c`) exist, and each
# return a signal of points that represents one of the parameters.
:a point param
:b point param
:c point param

# Put an empty sketch on the stack.
sketch
    # Put a reference to the cycle that is the sketch's exterior on the stack.
    exterior
        # Add an edge to the cycle, and put a reference to it on the stack.
        add_edge
            # `a` calls the function we defined above, which puts the signal for
            # one of the parameters on the stack. `to` is the name of the field
            # we want to write that to, which we refer to with `:to` here. `set`
            # is a function that sets the value of a field using these
            # parameters.
            :to a set
            # Similar thing to define the edge's curve.
            :curve line set
        # In principle, we'd still have the edge on the stack here, but I like
        # the idea that the indentation level is semantically relevant, and that
        # by dropping to the level of indentation where the edge was put on the
        # stack, the edge is dropped automatically.
        #
        # If not, we could also put an explicit `drop` here.
        #
        # On to the other edges.
        add_edge
            :to b set
            :curve line set
        add_edge
            :to c set
            :curve line set
    # Assuming we go with our "auto-drop via semantic indentation" idea, the
    # only thing left on the stack here is the sketch. Let's drop that too, and
    # at the same time tell the runtime that it's an output of this program.
    #
    # If a program can have multiple outputs, we could also pass a symbol here
    # to name it.
    output
